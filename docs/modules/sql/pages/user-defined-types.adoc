= User-Defined Types in SQL

User-Defined Types (also known as UDTs, nested types, or nested fields) allows you to create custom data types that can be referenced in the xref:sql:create-mapping.adoc[CREATE MAPPING statement].

UDTs are useful for creating and accessing hierarchical data structures, which can even be cyclic. See <<queryingExamples,examples>> for more information.

== Feature Overview

- All serialization formats (namely `portable`, `compact`, `java` and `avro`) are supported.
- Cyclic definitions are only supported for Java-serialized structures. (Portable and Compact formats do not support cyclic schemas at all. Avro support is currently limited to acyclic schemas.) Note that `INSERT`/`UPDATE` queries are disabled for mappings that use cyclic structures.
- Type options _always_ override mapping options. Specifically, if the mapping has only `__key` or `this` fields, and both the mapping and type define a schema (Portable class definition, Compact schema, Java class or Avro schema), the one defined by the type is used. This also means that, in such situations, as long as the type defines a schema, the mapping does not need to.
- If type schema is not specified, it will be resolved from the parent structure, which may be a mapping or another type.
- Type fields are optional and will be resolved from the schema if they are not specified. In that case, schema fields cannot be complex (`PORTABLE`/`COMPACT`/`RECORD`) for Portable/Compact/Avro formats. For Java format, complex fields are allowed and mapped to `OBJECT`. Type fields are resolved and materialized once the type is used in a `CREATE MAPPING` statement. The resolved fields can be checked by issuing a `GET_DDL` query after using the type in a mapping.

== Enabling Cycling Type Support
You can enable cyclic types by setting the `hazelcast.sql.experimental.custom.cyclic.types.enabled` property to `true` in the member configuration.
[tabs]
====
XML::
+
[source,xml]
----
<hazelcast>
    <properties>
        <property name="hazelcast.sql.experimental.custom.cyclic.types.enabled">true</property>
    </properties>
</hazelcast>
----

YAML::
+
[source,yaml]
----
hazelcast:
  properties:
    hazelcast.sql.experimental.custom.cyclic.types.enabled: true
----

Java::
+
[source,java]
----
final Config config = new Config();
config.setProperty("hazelcast.sql.experimental.custom.cyclic.types.enabled", "true");
----
====

== Creating Types

To create a new type, use the `CREATE TYPE` statement:

[source,sql]
----
CREATE [OR REPLACE] TYPE [IF NOT EXISTS] MyTypeName [(
    colName colType,
    ...
)] [OPTIONS (
    'javaClass'='com.mypackage.MyJavaClass' <1>
  | 'compactTypeName'='MyCompactRecordName' <2>
  | 'portableFactoryId'='123', 'portableClassId'='456', ['portableVersion'='789'] <3>
  | 'avroSchema'='{"type":"record","name":"myType","fields":[{"name":"colName","type":"colType"},...]}' <4>
)]
----
<1> In `java` format, you can use `javaClass` option to override the type class with a subclass. Note that you must provide a concrete class for `INSERT` statement to work, which makes `javaClass` option mandatory when the original type class is abstract or interface.
<2> In `portable` format, you can use `portableFactoryId`, `portableClassId` and `portableVersion` options to specify a portable ID for the type, which is only effective when the type is used for `__key` or `this` fields. `portableVersion` is optional, similarly to `CREATE MAPPING` statement. However, it is not possible to inherit some components from the parent, so portable ID components must be defined together. Incomplete definitions have the same effect as no definition.
<3> In `compact` format, you can use `compactTypeName` option to specify the Compact record name. If unspecified, it is defaulted to `<TypeName>CompactType`.
<4> In `avro` format, you can use `avroSchema` option to specify an inline Avro schema, which is only effective when the type is used for `__key` or `this` fields.

NOTE: `EXTERNAL NAME` aliases are not supported for types, column names must have the same name as their corresponding Java class field or Portable/Compact/Avro schema field.

NOTE: You can mix options that belong to different formats. When you create a mapping that references your UDT, the relevant options are used and the others are ignored, which makes it possible to use a UDT in multiple mappings having different serialization formats.

NOTE: To reference another type, you must provide the column list. Otherwise, in Java format, the column will be resolved as `OBJECT` type; in Portable, Compact and Avro formats, an exception will be thrown once the type is used in a mapping.

=== Java Format notes
For `java` format, if the column list is omitted, it will be automatically resolved from the corresponding
Java class. Note that the column list will only be extracted from the source class itself;
if it has columns that are inherited from a superclass, these columns will not be resolved.

=== Portable Format notes
When using the `portable` format, make sure that (`factoryId`, `classId`, `version`) tuples are unique within the cluster. Otherwise, deserialization issues may happen.

In addition, there is a rudimentary auto-resolution mechanism for column list. However, it is not recommended for use:
it relies on the Portable class being already registered (through internal Portable means,
e.g., when a configuration for Portable serialization is added) on the member executing the above SQL command.
This mechanism is not reliable since this command will fail if the member that executes the command doesn't have
the Portable class in question. Therefore, it is recommended to always specify the column list.

=== Support for Cycles
Cycles between types are only supported for Java format; however, the support is limited to querying only. **The existence of referenced types are only verified upon use in `CREATE MAPPING` statement.**

=== Replacing Types and Type Consistency
Currently, there is a limitation on the replacement of existing types:
if the replaced type was already used in a mapping, you need to fully replace that mapping
to update its data type information using the `DROP MAPPING` and `CREATE MAPPING` statements.
However, if the type hierarchy was not used in a mapping, any type in that hierarchy can be safely
changed, and these changes will appear in the new mapping. This is because the links
between types are symbolic (based on the name only), and they are only "materialized" once used in a mapping.

==== Creating Java Type Hierarchy with Cycles

Java classes for reference:

[source,java]
----
package com.example;

class A implements Serializable {
    public String name;
    public B b;
}
class B implements Serializable {
    public String name;
    public C c;
}
class C implements Serializable {
    public String name;
    public A a;
}
----

The following commands will create an interlinked type hierarchy:

NOTE: Order of execution of these commands doesn't matter.

===== Cyclic Type Hierarchy [[cyclicTypeDefinitions]]
[source,sql]
----
CREATE TYPE AType (
    name VARCHAR,
    b BType
) OPTIONS (
    'javaClass'='com.example.A'
);

CREATE TYPE BType (
    name VARCHAR,
    c CType
) OPTIONS (
    'javaClass'='com.example.B'
);

CREATE TYPE CType (
    name VARCHAR,
    a AType
) OPTIONS (
    'javaClass'='com.example.C'
);
----

=== Java Class Hierarchy for Reference:
The following classes will be used as a reference in the following sections to create types and mappings.

[source,java]
----
package com.example;

class User implements Serializable {
    public Long id;
    public String name;
    public Organization organization;
}

class Organization implements Serializable {
    public Long id;
    public String name;
    public Office office;
}

class Office implements Serializable {
    public Long id;
    public String name;
}
----

=== Creating Types [[normalTypeDefinitions]]

NOTE: Types can have a different name than their Java class or Portable/Compact/Avro schema. The only limitation is that the types must have distinct names within the set of names of all mappings and views as they all share the same namespace.

[source,sql]
----
CREATE TYPE Organization (
    id BIGINT
    name VARCHAR,
    office Office
) OPTIONS (
    'format'='java',
    'javaClass'='com.example.Organization'
);

CREATE TYPE Office (
    id BIGINT
    name VARCHAR
) OPTIONS (
    'javaClass'='com.example.Office'
);
----

=== Creating Mappings

NOTE: The `organization` column is explicitly specified as `Organization`. Without this definition, it would be auto-resolved as generic `OBJECT`, and would not allow querying its sub-columns.

==== Normal Type Hierarchy [[normalMappings]]

[source,sql]
----
CREATE MAPPING users (
    __key BIGINT,
    id BIGINT,
    name VARCHAR,
    organization Organization
) TYPE IMap OPTIONS (
    'keyFormat'='bigint',
    'valueFormat'='java',
    'valueJavaClass'='com.example.User'
);
----

==== Using Types from Cyclic Type Hierarchy [[cylicMappings]]

Using type hierarchy from the <<cyclicTypeDefinitions, cyclic types example>>, all the following
mappings will work.

[source,sql]
----
CREATE MAPPING tableA (
    __key BIGINT,
    name VARCHAR,
    b BType
) OPTIONS (
    'keyFormat'='bigint',
    'valueFormat'='java',
    'valueJavaClass'='com.example.A'
);

CREATE MAPPING tableB (
    __key BIGINT,
    name VARCHAR,
    c CType
) OPTIONS (
    'keyFormat'='bigint',
    'valueFormat'='java',
    'valueJavaClass'='com.example.B'
);

CREATE MAPPING tableC (
    __key BIGINT,
    name VARCHAR,
    a AType
) OPTIONS (
    'keyFormat'='bigint',
    'valueFormat'='java',
    'valueJavaClass'='com.example.C'
);
----

== Querying Support

Querying is provided with the field access operator which has the following syntax:
[source,sql]
----
(<mappingColumn>).typeAColumn.typeBColumn.typeCColumn
----

`mappingColumn` must be the top-level column inside a mapping that has a UDT as its type,
whereas `typeACOlumn`,`typeBColumn` and `typeCColumn` are all columns within the UDTs.

NOTE: The `mappingColumn` type must have the `typeACOlumn`,`typeBColumn` and `typeCColumn` columns defined in the `CREATE TYPE` command
or at least auto-resolved (Java types only). Otherwise, the query fails even if the underlying object
contains fields with these names.

=== Examples[[queryingExamples]]

==== Non-cyclic Type Hierarchy Querying

Following examples use <<normalTypeDefinitions, normal type definitions>> and <<normalMappings, normal mappings>>.

Basic querying:
[source,sql]
----
SELECT (organization).office.name FROM users
----

Selecting whole sub-object:
[source,sql]
----
SELECT (organization).office FROM users
----

NOTE: When selecting the entire object, the query will always try to return the underlying object verbatim.
For Java Types, this means returning an underlying Java class instance, which can fail with a `ClassNotFoundException`
if the class is not in the classpath of the client (or embedded server) JVM.
A way to avoid this is to select field by field instead. Additionally, this issue is not relevant for Portable, Compact and Avro types as sub-objects in these mappings and types are of `GenericRecord` subclass;
`PortableGenericRecord`, `CompactGenericRecord` and `org.apache.avro.generic.GenericRecord` are present in the base distribution of Hazelcast.

Using projections:
[source,sql]
----
SELECT (organization).id * 1000, ABS((organization).office.id) FROM users
----
Projections work as usual as field access expressions have virtually same semantics and possible usage contexts as normal
column projections.

==== Cyclic Type Hierarchy Querying

Following examples use <<cyclicTypeDefinitions, cyclic type definitions>> and following mapping:

[source,java]
----
package com.example;

class Wrapper {
    public A root;
}
----

[source,sql]
----
CREATE MAPPING test (
    __key BIGINT,
    root AType
) TYPE IMap OPTIONS (
    'keyFormat'='bigint',
    'valueFormat'='java',
    'valueJavaClass'='com.example.Wrapper'
)
----


Assuming following data is present in the table:

*Test table content*
[cols="1,1"]
|===
|__key BIGINT|root AType

| 1
| <a1>

| 2
| <a2>

|===

*A-instances* [[cyclicObjectInstances]]

A1

[source,java]
----
// Cyclic structure where C1 references the root - A1.
// A1 -> B1 -> C1 -> [A1]
final A a1 = new A();
a1.b = new B();
a1.b.c = new C();
// loop back to A1
a1.b.c.a = a1;

a1.name = "A1";
a1.b.name = "B1";
a1.b.c.name = "C1";
----

A2

[source,java]
----
// Cyclic structure with additional chain with loop back to A2.
// A2 -> B2 -> C2 -> A3 -> C3 -> [A2]
final A a2 = new A();
a2.b = new B();
a2.b.c = new C();
a2.b.c.a = new A();
a2.b.c.a.b = new B();
a2.b.c.a.b.c = new C();
// loop back to A2
a2.b.c.a.b.c.a = a2;

a2.name = "A2";
a2.b.name = "B2";
a2.b.c.name = "C2";
a2.b.c.a.name = "A3";
a2.b.c.a.b.name = "B3"
a2.b.c.a.b.c.name = "C3"
----

*Examples:*

Basic Query:

[source,sql]
----
SELECT
    (root).name AS v1,
    (root).b.name AS v2,
    (root).b.c.name AS v3,
    (root).b.c.a.name AS v4
FROM test
WHERE __key = 1
----

Result:
[cols="1,1,1,1"]
|===
|v1 VARCHAR|v2 VARCHAR|v3 VARCHAR|v4 VARCHAR

|'A1'
|'B1'
|'C1'
|'A1'

|===

Multiple Iteration Loop back through Cycle:

[source,sql]
----
SELECT
    (root).b.c.a.b.c.a.b.c.a.b AS v1,
FROM test
WHERE __key = 1
----

Result:
[cols="1"]
|===
|v1 VARCHAR

|'B1'

|===

Accessing additional cyclic chain:

[source,sql]
----
SELECT
    (root).b.c.a.name AS v1,
    (root).b.c.a.b.name AS v2,
    (root).b.c.a.b.c.name AS v3,
    (root).b.c.a.b.c.a.name AS v4
FROM test
WHERE __key = 2
----

Result:
[cols="1,1,1,1"]
|===
|v1 VARCHAR|v2 VARCHAR|v3 VARCHAR|v4 VARCHAR

|'A3'
|'B3'
|'C3'
|'A2'
|===

== `INSERT` and `UPDATE` Support

INSERT and UPDATE queries are supported in a limited way, specifically:

- `INSERT` and `UPDATE` queries are only supported for non-cyclic type hierarchies. Presence of a cycle in a type hierarchy automatically disables the ability to run these queries against any MAPPING that uses UDTs from that type hierarchy.
- `INSERT` queries require specifying the full list of columns even if the column of a nested type needs to be set to `NULL`.
- `UPDATE` queries only work on the root column and also require the full list of columns and sub-columns to work.
Updating sub-columns is technically possible by specifying column projections in place of sub-columns that shouldn't be changed.
- Both `UPDATE` and `INSERT` work through the usage of Row Value expression (which is similar to `VALUES` clause of `INSERT`).

=== Examples[[upsertExamples]]

Following examples use <<normalTypeDefinitions, normal type definitions>> and <<normalMappings, normal mappings>>.

NOTE: The order of column values is identical to the order of columns specified when executing the underlying `CREATE MAPPING` and `CREATE TYPE` statements.

Basic Insert of UDT-column:

[source,sql]
----
INSERT INTO users VALUES (1, 'testUser', (1, 'organization1', (1, 'office1')))
----

Skipping initialization of certain columns:

`(organization).name` and `(organization).office.id` are `null` in this example.

[source,sql]
----
INSERT INTO users VALUES (1, 'testUser', (1, null, (null, 'office1')))
----

Replacing whole column:

[source,sql]
----
UPDATE users SET organization = (2, 'organization2', (2, 'office2'))
----

Replacing nested column value:

[source,sql]
----
UPDATE users SET organization = ((organization).id, (organization).name, ((organization).office.id, 'new-office-name'))
----

NOTE: Updating UDT-based columns requires providing a value for every column in the UDT and its child UDTs, however
`null` can also be specified in place of nested UDT column to initialize it to `null`. Not providing full list of columns
will cause a query validation error.

Inserting with Query Parameter (java only):

[source,java]
----
final Office office = new Office();
office.id = 1L;
office.name = "office1";

final Organization organization = new Organization();
organization.id = 1L;
organization.name = "organization1";
organization.office = office;

hz.getSql().execute("INSERT INTO users VALUES (1, 'user1', ?)", organization);
----

Updating with Query Parameter:

Using `organization` from the example above.

[source,java]
----
hz.getSql().execute("UPDATE users SET organization = ?", organization);
----

Updating nested UDT column with Query Parameter:

[source,java]
----
hz.getSql().execute("UPDATE users SET organization = ((organization).id, (organization).name, ?)", office);
----

== Rolling Upgrade Notes
You must drop all user-defined types and mappings with UDTs before the rolling upgrade, and recreate them with the new semantics after upgrading.
